<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<meta name="format-detection" content="email=no,telephone=no,address=no">
<title>=^.^=</title>
<style>
.outer {
	position: relative;
	overflow: hidden;
	width: 400px;
	height: 200px;
}

.outer::before {
	content: '';
	position: absolute;
	inset: 0;
	display: block;
	background: url( "bg_001.jpg" ) 50% 50% / cover;
	transition: filter .6s;
}

.outer.-unlocked::before {
	filter: blur( 8px );
}

.lock {
	position: absolute;
	z-index: 1;
	display: block;
	transition: transform .6s, opacity .6s;
}

.outer.-unlocked .lock {
	opacity: 0;
	transform: scale( 1.5 );
	pointer-events: none;
}

.content {
	position: absolute;
	inset: 0;
	transform: scale( 1.5 );
	display: flex;
	align-items: center;
	justify-content: center;
	color: #fff;
	opacity: 0;
	font-family: sans-serif;
	transition: transform .6s, opacity .6s;
}

.outer.-unlocked .content {
	opacity: 1;
	transform: scale( 1 );
	pointer-events: none;
}
</style>
</head>
<body>

<div class="outer">
	<svg class="lock" width="400" height="200" viewBox="0 0 400 200">
		<path id="guide" d="m50,100s73.96,0,74.99,0c.58-.05.01-36.34.01-40h50v80h50V60h50v40h75" fill="none" stroke="red" display="none"/>
		<!-- 外枠 -->
		<path d="m225,156h-50c-8.84,0-16-7.16-16-16v-64h-17.83c.04,3.73.07,7.65.08,11.21.01,4.04,0,7.1-.04,9.33-.02,1.44-.06,2.51-.11,3.36-.67,11.7-9.57,15.59-14.72,16.04-.46.04-.93.06-1.39.06H50c-8.84,0-16-7.16-16-16s7.16-16,16-16h59.23c-.04-6.8-.13-14.17-.17-17.77-.04-3.13-.06-5.43-.06-6.23,0-8.84,7.16-16,16-16h50c8.84,0,16,7.16,16,16v64h18V60c0-8.84,7.16-16,16-16h50c8.84,0,16,7.16,16,16v24h59c8.84,0,16,7.16,16,16s-7.16,16-16,16h-75c-8.84,0-16-7.16-16-16v-24h-18v64c0,8.84-7.16,16-16,16Z" fill="#fff" fill-opacity=".50" stroke="#000" stroke-width="1" stroke-miterlimit="10"/>
		<!-- ゴール -->
		<circle cx="350" cy="100" r="14" fill="none" stroke="#000" stroke-dasharray="0 0 1 2" stroke-width="1.5" opacity=".5"/>
		<!-- テキスト -->
		<path d="m225.23,65.05c0,.52,0,1.13.36,1.6.2.25.59.58,1.31.58s1.12-.32,1.31-.58c.36-.47.36-1.08.36-1.6v-4.36h1.3v4.5c0,.92-.09,1.6-.68,2.25-.67.7-1.55.94-2.29.94s-1.62-.23-2.29-.94c-.59-.65-.68-1.33-.68-2.25v-4.5h1.3v4.36Zm8.89-4.36h1.3v.86c.23-.31.9-1.04,2.14-1.04.88,0,1.69.36,2.14,1.03.38.56.43,1.17.43,2v4.63h-1.3v-4.59c0-.45-.04-.97-.34-1.37-.25-.32-.65-.54-1.22-.54-.45,0-.94.13-1.31.58-.5.59-.54,1.48-.54,2.02v3.91h-1.3v-7.47Zm11.56-5.65v13.13h-1.3v-13.13h1.3Zm3.78,9.42c0-2.27,1.67-3.94,3.96-3.94s3.96,1.67,3.96,3.94-1.69,3.92-3.96,3.92-3.96-1.66-3.96-3.92Zm1.33,0c0,1.84,1.3,2.77,2.63,2.77s2.63-.95,2.63-2.77-1.26-2.79-2.63-2.79-2.63.97-2.63,2.79Zm16.22-1.67c-.68-.86-1.67-1.12-2.34-1.12-1.39,0-2.65.97-2.65,2.79s1.3,2.77,2.63,2.77c.77,0,1.73-.34,2.41-1.17v1.55c-.81.59-1.67.77-2.38.77-2.32,0-4-1.66-4-3.91s1.69-3.96,4-3.96c1.19,0,1.96.47,2.32.72v1.55Zm5.13-7.74v8.43l2.74-2.77h1.69l-3.21,3.21,3.78,4.27h-1.69l-2.99-3.4-.32.32v3.08h-1.3v-13.13h1.3Zm-136.33,3.49c-.16-.32-.43-.68-.7-.9-.23-.18-.67-.41-1.35-.41-1.19,0-2.02.74-2.02,1.85,0,.47.13.74.45,1.04.36.36.81.56,1.26.76l1.15.5c.7.31,1.35.63,1.85,1.13.61.61.86,1.31.86,2.18,0,2.21-1.64,3.69-3.8,3.69-.79,0-1.78-.16-2.61-.97-.59-.58-.95-1.4-1.12-2.12l1.3-.36c.09.63.38,1.17.72,1.53.52.52,1.12.67,1.73.67,1.64,0,2.41-1.17,2.41-2.38,0-.54-.16-1.01-.59-1.4-.34-.32-.81-.54-1.44-.83l-1.08-.5c-.47-.22-1.06-.47-1.6-.99-.52-.5-.83-1.06-.83-1.96,0-1.85,1.42-3.1,3.37-3.1.74,0,1.33.14,1.93.54.49.32.9.81,1.17,1.33l-1.06.7Zm6.73-3.49v13.13h-1.3v-13.13h1.3Zm4.9,1.91c.5,0,.92.41.92.92s-.41.92-.92.92-.92-.41-.92-.92.41-.92.92-.92Zm.65,3.75v7.47h-1.3v-7.47h1.3Zm9.97-5.65h1.3v13.13h-1.3v-1.04c-.43.56-1.24,1.26-2.56,1.26-1.89,0-3.64-1.33-3.64-3.96s1.73-3.91,3.64-3.91c1.44,0,2.21.79,2.56,1.24v-6.72Zm-4.86,9.38c0,1.6.9,2.81,2.45,2.81s2.48-1.31,2.48-2.79c0-1.93-1.33-2.77-2.48-2.77-1.28,0-2.45.94-2.45,2.75Zm17.03,1.84c-.22.41-.54.86-.92,1.21-.68.61-1.53.92-2.48.92-1.8,0-3.69-1.13-3.69-3.91,0-2.23,1.37-3.96,3.62-3.96,1.46,0,2.38.72,2.83,1.37.47.67.74,1.82.7,2.81h-5.82c.02,1.55,1.08,2.54,2.38,2.54.61,0,1.1-.18,1.53-.54.34-.29.61-.67.77-1.03l1.08.59Zm-1.28-2.65c-.22-1.17-1.1-1.94-2.2-1.94s-2,.83-2.2,1.94h4.39Zm26.03,75.27v6.28h-1.3v-6.28h-.79v-1.19h.79v-2.7h1.3v2.7h1.3v1.19h-1.3Zm3.85,2.57c0-2.27,1.67-3.94,3.96-3.94s3.96,1.67,3.96,3.94-1.69,3.92-3.96,3.92-3.96-1.66-3.96-3.92Zm1.33,0c0,1.84,1.3,2.77,2.63,2.77s2.63-.95,2.63-2.77-1.26-2.79-2.63-2.79-2.63.97-2.63,2.79Z"/>

		<g id="cursor">
			<circle r="14" stroke="#fff"/>
			<path d="m.47-8.1c-.75-.72-1.95-.69-2.66.07-.72.75-.69,1.95.07,2.66L1.05-2.35h-7.53c-1.04,0-1.88.84-1.88,1.88s.84,1.88,1.88,1.88H1.05l-3.18,3.03c-.75.72-.78,1.91-.07,2.66.72.75,1.91.78,2.66.07L8.5-.46.47-8.1Z" fill="#ccc"/>
		</g>
	</svg>
	<div class="content">
		こんにちは
	</div>
</div>

<button type="button" id="reset-button">やりなおす</button>

<script type="module">
const outerEl = document.querySelector( '.outer' );
const svgEl = outerEl.querySelector( 'svg' );
const guideLineEl = svgEl.querySelector( '#guide' );
const cursorLineEl = svgEl.querySelector( '#cursor' );
const pathLength = guideLineEl.getTotalLength();

const state = {
	pathLength,
	points: toPoints( guideLineEl, pathLength / 2 ),
	currentPoint: 0,
	get completed() {

		return this.currentPoint >= this.points.length;

	}
};

const position = guideLineEl.getPointAtLength( 0 )
cursorLineEl.style.transform = `translate( ${ position.x }px, ${ position.y }px )`;
//

const dragInfo = {
	activePointerId: null,
}
function dragStart( event ) {

	if ( !! dragInfo.activePointerId ) return;

	const svgRect = svgEl.getBoundingClientRect();
	const x = event.clientX - svgRect.left;
	const y = event.clientY - svgRect.top;

	// 最初の10個以内の点との距離が近ければ、スタート
	const closest = {
		index: - 1,
		distance: Infinity,
	};
	const maxDistance = 32;
	const maxDistanceSq = maxDistance ** 2;
	const points = state.points;

	for ( let i = 0; i < 10; i ++ ) {

		const point = getUnProjectedPoint( svgEl, points[ i ].x, points[ i ].y );
		const distanceSq = ( point.x - x ) ** 2 + ( point.y - y ) ** 2;
		if ( distanceSq <= maxDistanceSq && distanceSq < closest.distance ** 2 ) {

			closest.index = i;
			closest.distance = Math.sqrt( distanceSq );

		}

	}

	if ( closest.index !== - 1 ) {

		console.log( 'start' );
		dragInfo.activePointerId = event.pointerId;
		document.addEventListener( 'pointermove', dragging );

	}

}


const DISTANCE_THRESHOLD = 16;
function dragging( event ) {

	if ( event.pointerId !== dragInfo.activePointerId ) return;

	const svgRect = svgEl.getBoundingClientRect();
	const x = event.clientX - svgRect.left;
	const y = event.clientY - svgRect.top;

	// 現在の周辺の point 10個から、現在位置を判定
	const rangeStart = Math.max( state.currentPoint - 32, 0 );
	const rangeEnd = Math.min( state.currentPoint + 32, state.points.length - 1 );
	const points = state.points.slice( rangeStart, rangeEnd );

	const closest = {
		index: - 1,
		distance: Infinity,
	};
	const maxDistanceSq = DISTANCE_THRESHOLD ** 2;

	for ( let i = 0; i < points.length; i ++ ) {

		const point = getUnProjectedPoint( svgEl, points[ i ].x, points[ i ].y );
		const distanceSq = ( point.x - x ) ** 2 + ( point.y - y ) ** 2;
		if ( distanceSq <= maxDistanceSq && distanceSq < closest.distance ** 2 ) {

			closest.index = i + rangeStart;
			closest.distance = Math.sqrt( distanceSq );

		}

	}

	if ( state.points.length - 3 <= closest.index ) {

		// 最終ポイントから 3 個以内前までに到達したら、ゴールとする
		console.log( 'end' );
		state.currentPoint = state.points.length;
		const distance = getDistanceFromPathStart( state.pathLength, state.points, state.currentPoint );
		const position = guideLineEl.getPointAtLength( distance );
		cursorLineEl.style.transform = `translate( ${ position.x }px, ${ position.y }px )`;
		outerEl.classList.add( '-unlocked' );

		dragEnd();
		return;

	} else if ( closest.index === - 1 ) {

		state.currentPoint = 0;
		const position = guideLineEl.getPointAtLength( 0 );
		cursorLineEl.style.transform = `translate( ${ position.x }px, ${ position.y }px ) rotate( 0deg )`;
		dragEnd();

	} else {

		state.currentPoint = closest.index;
		const distance = getDistanceFromPathStart( state.pathLength, state.points, state.currentPoint );
		const position = guideLineEl.getPointAtLength( distance );
		const deltaPosition = guideLineEl.getPointAtLength( distance - 0.001 );
		const angle = Math.atan2( deltaPosition.y - position.y, deltaPosition.x - position.x ) + Math.PI;
		cursorLineEl.style.transform = `translate( ${ position.x }px, ${ position.y }px ) rotate( ${ angle }rad )`;

	}

}

function dragEnd() {

	document.removeEventListener( 'pointermove', dragging );
	dragInfo.activePointerId = null;

}

function reset() {

	state.currentPoint = 0;
	const position = guideLineEl.getPointAtLength( 0 );
	cursorLineEl.style.transform = `translate( ${ position.x }px, ${ position.y }px ) rotate( 0deg )`;
	outerEl.classList.remove( '-unlocked' );

}


svgEl.addEventListener( 'pointerdown', dragStart );
document.addEventListener( 'pointerup', dragEnd );
document.addEventListener( 'pointercancel', dragEnd );
document.getElementById( 'reset-button' ).addEventListener( 'click', reset );

// -----------------------------------------------------------------------------

function toPoints( pathEl, numOfPoints ) {

	const pathLength = pathEl.getTotalLength();
	const points = [];
	for ( let i = 0; i < numOfPoints; i ++ ) {

		points.push( pathEl.getPointAtLength( pathLength / numOfPoints * i ) );

	}

	return points;

}

function getUnProjectedPoint( svgEl, pointX, pointY ) {

	const svgPoint = svgEl.createSVGPoint();
	svgPoint.x = pointX;
	svgPoint.y = pointY;
	const unProjectedPoint = svgPoint.matrixTransform( svgEl.getCTM() );
	return unProjectedPoint;

}

function getDistanceFromPathStart( pathLength, points, pointIndex ) {

	return ( pathLength / points.length ) * pointIndex;

}
</script>



</body>
</html>
